# 信息的表示和处理

## 信息存储

字节是八位的块，是最小的可寻址内存单位。

### 十六进制

十进制|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
十六进制|0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F
二进制|0000|0001|0010|0011|0100|0101|0110|0111|1000|1001|1010|1011|1100|1101|1110|1111

十进制->十六进制：反复用16除x，得到商q和余数r，即x=q*16+r，以r为最后结果的较高位反复进行这个流程。

### 字数据

字长：指明指针数据的标称大小。决定虚拟地址空间最大大小。

原本的计算机是32字节，后来迁移到64字节。高字节机器兼容低字节指令，反之则不。

对于不同的机器字长，默认的数据类型长度也是不同的，所以为了避免不同机器带来的不同长度导致的漏洞，C99标准就提供了int32_t等类型固定数据长度。但是C语言只规定了数字下界没有规定上界。

### 寻址和字节顺序

+ 小端法：最低有效位在低位。最常用。
+ 大端法：最高有效位在低位。

字节顺序重要的情况：

1. 不同类型机器传输二进制数据。
2. 阅读表示整数数据的字节序列。
3. 编写规避正常类型系统的程序。

通过`man ascii`命令可以得到ASCII字符码表。

### 字符串

字符串是一个以null为结尾的字符数组，以标准编码表示（如ASCII码），所以字符码在不同平台都能得到同样的数据，所以文本数据比二进制数据更具备平台独立性。

Unicode标准对ASCII标准进行推广进行兼容。

### 表示代码

对于不同的平台，系统对于同一个指令的编码是不同的，从而不同平台之间二进制代码很难移植。

### 布尔代数

由于二进制是计算机科学核心，所以关于0和1的研究体系化为布尔代数。

运算|布尔运算|逻辑运算
:--:|:----:|:-----:
非|~|NOT
与|&|AND
或|\||OR
异或|^|XOR

对于任意向量，a^a=0。

将单位组成位向量进行依次进行位运算。

可以用位向量对集合进行编码，1代表有效，0代表无效。

### 位级运算

即对C语言的数据进行位运算，即先将十六进制展开为二进制，然后依次位运算，然后重新转为十六进制。

```c
void swap(int *x, int* y) {
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

这是一个不用temp位置保存而进行交换的函数，这是如何实现的？

步骤|\*x|\*y
:--:|:-:|:-:
初始|a|b
1|a|a^b
2|a^a^b|a^b
3|a^a^b|a^a^b^a^b
最后|b|a

另一个用法就算掩码运算，即从一个字中选出位的集合，如0xFF就表示取出字的低八位，如x&0xFF表示取出x的低八位。

### 逻辑运算

与位运算不同：

+ 只有参数只为0或1时才能等价于逻辑运算。
+ 如果第一个参数求值就能得到结果那么就不会对第二个参数求值。

对于第二种情况，a&&5/a不会造成0除，p&&*p++不会导致间接引用空指针。

### 移位运算

移位运算左右都可以结合。

+ 左移直接右部补0。
+ 右移分为逻辑右移（直接补0）和算术右移（补最高有效位 ）。

负数算术右移补1，正数算术右移补0（以补码表示）。

应该避免位移量小于数的位数，一般程序用模运算来避免这个问题。

移位运算的优先级低于加减运算。

## 整数表示

### 整型

C语言通过int表示整型，并给出char、short、long来规定整型长度，unsigned规定整型的范围。

C/CPP支持有符号数和无符号数，而Java只支持有符号数。

### 无符号数编码

对于向量$\vec{x}=[x_{w-1},\cdots,x_0]$，$\vec{x}$的无符号数值为$\sum\limits_{i=0}^{w-1}x_i2^i$。

对于w位编码，范围是$[0,2^w-1]$。

### 有符号数编码

对于向量$\vec{x}=[x_{w-1},\cdots,x_0]$，$\vec{x}$的无符号数值为$-x_{x-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i$。最高位是符号位。

一般是从原码到反码再到补码对补码进行理解。

从数值上是指，正数没什么变化，如果是负数，则先减去一个最大单个位的负数，然后再用后面位的正数来加上去。所以负数越大（即越接近0）则后面的数值越大。

对于w位编码，范围是$[-2^{w-1},2^{w-1}-1]$。

而实际上对于C语言，由于这种最大和最小值的不等性可能运算会出现问题，所以C语言强制规定最大值和最小值的绝对值相等，即不能表示-128只能表示到-127。

### 有符号数和无符号数转换

对于C语言而言可以直接强制类型转换，但是这种转换并不改变底层的具体数值，而只是改变解释数值的方式。

补码转无符号数：$x=x+x_{w-1}2^w$。其中$x_{w-1}$决定数值正负性。

无符号数转补码：$x=-x_{w-1}2^w+x$。

### C语言有符号数和无符号数

C语言在对符号数和无符号数进行转换时会使用以上的转换公式。

如果两个操作数一个是有符号一个是无符号，则默认假设这两个数都是非负的，从而转换为无符号数来执行运算。

除了C语言外其他语言很少支持无符号数，因为无符号数容易产生漏洞。

### 拓展位

对于大数要转换为小数，不改变值是不可能的，而小数转为大数则总是可能的。

对于无符号数使用零拓展：直接高位添加0。

对于有符号数使用符号拓展：高位添加最高有效位。

### 截断位

如果将大数转换为小数，则要改变其值，称为截断。

若截断k位，则$x=x\textrm{mode}2^k$。

如果是无符号数则直接利用该公式，如果是补码形式，则先转为无符号数进行取模再重新转为补码。

## 整数运算

### 原码加法

$x+y=\left\{\begin{array}{cc}
    x+y-2^w, &2^w\leqslant x+y<2^{w+1}\\
    x+y, &x+y<2^w \\
\end{array}\right.$。

判断溢出：$x+(y-2^w)<x$。

求反：$-x=2^x-x$。其中$x>0$。

### 补码加法

$x+y=\left\{\begin{array}{cc}
    x+y-2^w, &2^{w-1}\leqslant x+y\\
    x+y, &-2^{w-1}\leqslant x+y<2^{w-1} \\
    x+y+2^w, &x+y<-2^{w-1}
\end{array}\right.$。

### 补码非

$-x=\left\{\begin{array}{cc}
    \min, &x=\min \\
    -x, &x>\min
\end{array}\right.$。

一般是每位取反然后再加一。

### 原码乘法

$x*y=(x*y)\mod2^w$。

### 补码乘法


