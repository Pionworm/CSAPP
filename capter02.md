# 信息的表示和处理

## 信息存储

字节是八位的块，是最小的可寻址内存单位。

### 十六进制

十进制|0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15
:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:
十六进制|0|1|2|3|4|5|6|7|8|9|A|B|C|D|E|F
二进制|0000|0001|0010|0011|0100|0101|0110|0111|1000|1001|1010|1011|1100|1101|1110|1111

十进制->十六进制：反复用16除x，得到商q和余数r，即x=q*16+r，以r为最后结果的较高位反复进行这个流程。

### 字数据

字长：指明指针数据的标称大小。决定虚拟地址空间最大大小。

原本的计算机是32字节，后来迁移到64字节。高字节机器兼容低字节指令，反之则不。

对于不同的机器字长，默认的数据类型长度也是不同的，所以为了避免不同机器带来的不同长度导致的漏洞，C99标准就提供了int32_t等类型固定数据长度。但是C语言只规定了数字下界没有规定上界。

### 寻址和字节顺序

+ 小端法：最低有效位在低位。最常用。
+ 大端法：最高有效位在低位。

字节顺序重要的情况：

1. 不同类型机器传输二进制数据。
2. 阅读表示整数数据的字节序列。
3. 编写规避正常类型系统的程序。

通过`man ascii`命令可以得到ASCII字符码表。

### 字符串

字符串是一个以null为结尾的字符数组，以标准编码表示（如ASCII码），所以字符码在不同平台都能得到同样的数据，所以文本数据比二进制数据更具备平台独立性。

Unicode标准对ASCII标准进行推广进行兼容。

### 表示代码

对于不同的平台，系统对于同一个指令的编码是不同的，从而不同平台之间二进制代码很难移植。

### 布尔代数

由于二进制是计算机科学核心，所以关于0和1的研究体系化为布尔代数。

运算|布尔运算|逻辑运算
:--:|:----:|:-----:
非|~|NOT
与|&|AND
或|\||OR
异或|^|XOR

对于任意向量，a^a=0。

将单位组成位向量进行依次进行位运算。

可以用位向量对集合进行编码，1代表有效，0代表无效。

### 位级运算

即对C语言的数据进行位运算，即先将十六进制展开为二进制，然后依次位运算，然后重新转为十六进制。

```c
void swap(int *x, int* y) {
    *y = *x ^ *y;
    *x = *x ^ *y;
    *y = *x ^ *y;
}
```

这是一个不用temp位置保存而进行交换的函数，这是如何实现的？

步骤|\*x|\*y
:--:|:-:|:-:
初始|a|b
1|a|a^b
2|a^a^b|a^b
3|a^a^b|a^a^b^a^b
最后|b|a

另一个用法就算掩码运算，即从一个字中选出位的集合，如0xFF就表示取出字的低八位，如x&0xFF表示取出x的低八位。

### 逻辑运算

与位运算不同：

+ 只有参数只为0或1时才能等价于逻辑运算。
+ 如果第一个参数求值就能得到结果那么就不会对第二个参数求值。

对于第二种情况，a&&5/a不会造成0除，p&&*p++不会导致间接引用空指针。

### 移位运算

移位运算左右都可以结合。

+ 左移直接右部补0。
+ 右移分为逻辑右移（直接补0）和算术右移（补最高有效位 ）。

负数算术右移补1，正数算术右移补0（以补码表示）。

应该避免位移量小于数的位数，一般程序用模运算来避免这个问题。

移位运算的优先级低于加减运算。

## 整数表示

### 整型

C语言通过int表示整型，并给出char、short、long来规定整型长度，unsigned规定整型的范围。

C/CPP支持有符号数和无符号数，而Java只支持有符号数。

### 无符号数编码

对于向量$\vec{x}=[x_{w-1},\cdots,x_0]$，$\vec{x}$的无符号数值为$\sum\limits_{i=0}^{w-1}x_i2^i$。

对于w位编码，范围是$[0,2^w-1]$。

### 有符号数编码

对于向量$\vec{x}=[x_{w-1},\cdots,x_0]$，$\vec{x}$的无符号数值为$-x_{x-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i$。最高位是符号位。

一般是从原码到反码再到补码对补码进行理解。

从数值上是指，正数没什么变化，如果是负数，则先减去一个最大单个位的负数，然后再用后面位的正数来加上去。所以负数越大（即越接近0）则后面的数值越大。

对于w位编码，范围是$[-2^{w-1},2^{w-1}-1]$。

而实际上对于C语言，由于这种最大和最小值的不等性可能运算会出现问题，所以C语言强制规定最大值和最小值的绝对值相等，即不能表示-128只能表示到-127。

### 有符号数和无符号数转换

对于C语言而言可以直接强制类型转换，但是这种转换并不改变底层的具体数值，而只是改变解释数值的方式。

补码转无符号数：$x=x+x_{w-1}2^w$。其中$x_{w-1}$决定数值正负性。

无符号数转补码：$x=-x_{w-1}2^w+x$。

### C语言有符号数和无符号数

C语言在对符号数和无符号数进行转换时会使用以上的转换公式。

如果两个操作数一个是有符号一个是无符号，则默认假设这两个数都是非负的，从而转换为无符号数来执行运算。

除了C语言外其他语言很少支持无符号数，因为无符号数容易产生漏洞。

### 拓展位

对于大数要转换为小数，不改变值是不可能的，而小数转为大数则总是可能的。

对于无符号数使用零拓展：直接高位添加0。

对于有符号数使用符号拓展：高位添加最高有效位。

### 截断位

如果将大数转换为小数，则要改变其值，称为截断。

若截断k位，则$x=x\textrm{mode}2^k$。

如果是无符号数则直接利用该公式，如果是补码形式，则先转为无符号数进行取模再重新转为补码。

## 整数运算

### 原码加法

$x+y=\left\{\begin{array}{cc}
    x+y-2^w, &2^w\leqslant x+y<2^{w+1}\\
    x+y, &x+y<2^w \\
\end{array}\right.$。

判断溢出：$x+(y-2^w)<x$。

求反：$-x=2^x-x$。其中$x>0$。

### 补码加法

$x+y=\left\{\begin{array}{cc}
    x+y-2^w, &2^{w-1}\leqslant x+y\\
    x+y, &-2^{w-1}\leqslant x+y<2^{w-1} \\
    x+y+2^w, &x+y<-2^{w-1}
\end{array}\right.$。

### 补码非

$-x=\left\{\begin{array}{cc}
    \min, &x=\min \\
    -x, &x>\min
\end{array}\right.$。

一般是每位取反然后再加一。

### 原码乘法

$x*y=(x*y)\mod2^w$。

### 补码乘法

原码乘法和补码乘法具有位级等价性。

转为原码，$x*y=(x*y)\mod2^w$，然后转为补码。

### 乘以常数

由于补码乘法代价较高，所以计算机努力将乘法通过移位和加法实现。

乘2倍数的常数就是左移对应位。可能出现溢出问题。

对于乘以非2倍数的常数，则用加减法和移位实现。如乘14，则是(x<<3)+(x<<2)+(x<<1)，或者优化为(x<<4)-(x<<1)。

从而根据上面的例子可以看出编译器对于乘法的优化：

对x*K，将K表示为二进制序列，若存在一组从位置n
到位置m的连续1(n>=m)，则可以对其进行优化，使得从加法变为减法。即从(x<<n)+(x<<(n-1))+...+(x<<m)优化为(x<<(n+1))-(x<<m)。

如14就是1110，n=3，m=1。

### 除以2的幂

除以2的幂可以通过算术右移来实现。可能存在丢失精度的问题。如果是无符号数则是逻辑右移。

$x/2^w=x>>w$。默认是向下舍入。

原码：$x/2^w=(x+(1<<w)-1)>>w$，向上舍入。

补码：$x/2^w=(x+2^w-1)/2^w$，向上舍入。

## 浮点数

对$x*2^y$类型的有理数进行编码，对于非常大的和非常接近0的数的运算都十分有用。

使用IEEE754标准来规范浮点数。

### 二进制小数

形如$b=b_mb_{m-1}\cdots b_1b_0.b_{-1}\cdots b_{-n}=\sum\limits_{i=-n}^m2^i\times b_i$。

对于0.5类似的十进制小数二进制小数无法完全表示，所以只能增长位数来尽量提高精度。

### IEEE标准

$V=(-1)^s\times M\times2^E$：

+ 符号s决定这个数的正负号，1负0正，如果数值为0则存在正0和负0的区别。
+ 尾数M是一个二进制小数，范围是1~2-e或0~1-e。其中e是一个极小的小数。
+ 阶码E是对浮点数加权，权重为2的E次幂。

IEEE标准存在四种情况：

1. 规格化值：
   + E不为全0也不为全1。此时阶码被解释为移码，E的实际值为E无符号数值减去偏置值，偏置值为$2^{k-1}-1$，如单精度就是2的7次幂减一为127，从而单精度浮点数的阶码范围是-126~+127。
   + M被解释为小数值，默认是0.x，但是首部隐含一个1，即最后结果是1.x，从而位数在1到2之间。
2. 非规格化值：
   + E为全0时表示该数非规格化，E=1-偏置值。如单精度就是-127。
   + M就是小数字段值，此时就不包含开头隐含的1。
   + 若M==0：非规格化数用于表示数值0，因为使用规格化数必须要求M>=1不能表示0，此时存在+0和-0的不同。
   + 若M!=0：表示非常接近0的数，这类处理方式称为渐进溢出。
3. 无穷大：
   + E为全1时，如单精度就是-128。
   + M==0。
   + 当s==0时代表正无穷，s==1时代表负无穷。
   + 当两个大数相乘溢出或除以0时表示。
4. NAN：
   + E为全1时，如单精度就是-128。
   + M!=0。
   + NAN是Not a number的简写。
   + 当运算结果不能是实数或无穷时用于表示，如虚数。也可以用于表示未初始化数据。

### 舍入

令x为原值，舍入值为x~，比x更小最近的整数为x-，比x更大最近的整数为x+：

+ 向偶数舍入：向更近的整数进行舍入，若为x.5，则向偶数舍入。如果将值按其他方式进行舍入，如果求平均值，若向下舍则小于平均值，向上舍则大于平均值。且对于二进制小数优先末尾0。
+ 向零舍入：不用判断哪个更近，向零舍入。x~<=|x|。
+ 向下舍入：不用判断哪个更近，向更小值舍入。x-<=x。
+ 向上舍入：不用判断哪个更近，向更大值舍入。x<=x+。

### 浮点运算

当运算数中存在特殊值时：

+ N/-0=-∞。
+ N/+0=+∞。

对于一般的浮点运算：

+ 可交换：x+y=y+x，x\*y=y\*x。
+ 不可结合：(x+y)+z!=x+(y+z)，(x\*y)\*z!=x\*(y\*z)。因为可能溢出或舍入，如(3+1e10)-1e10由于舍入会变成0，因为一般值在浮点运算下存在逆元，即x+-x=0。而+∞-∞=NaN，NaN+x=NaN。
+ 不可分配：x\*(y+z)!=x\*y+x\*z。因为可能产生溢出，如1e20\*(1e20-1e20)=0!=1e20\*1e20-1e20\*1e20=∞-∞=NaN。
+ 单调性：若x>=y，则z+x>=z+y，若z>=0，则x\*z>=y\*z，若z<=0，则x\*z<=y\*z。无符号数或补码表示的有符号数则没有该性质。
+ 若x!=NaN，则a\*a>=0。

### C语言浮点数

float对应单精度浮点数，double对应双精度浮点数。

C语言标准不规范使用IEEE标准，所以没有规定舍入特殊值等处理方式。GCC会定义常数INFINITY表示+∞，NAN表示NaN。

假设机器为32位：

+ int->float：不会溢出，但是可能舍入。
+ int/float->double：不变。
+ double->float：可能溢出也可能舍入。
+ float/double->int：可能溢出也可以舍入。向0舍入，因为去掉小数部分。
